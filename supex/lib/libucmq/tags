!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARR_SIZE	src/internal.h	32;"	d
ATOMIC_ADD	src/atomic.h	104;"	d
ATOMIC_ADD	src/atomic.h	33;"	d
ATOMIC_AND	src/atomic.h	134;"	d
ATOMIC_AND	src/atomic.h	36;"	d
ATOMIC_BIT_OFF	src/atomic.h	161;"	d
ATOMIC_BIT_ON	src/atomic.h	158;"	d
ATOMIC_BIT_XCHG	src/atomic.h	164;"	d
ATOMIC_CAS	src/atomic.h	27;"	d
ATOMIC_CAS	src/atomic.h	81;"	d
ATOMIC_CLEAR	src/atomic.h	30;"	d
ATOMIC_CLEAR	src/atomic.h	95;"	d
ATOMIC_GET	src/atomic.h	17;"	d
ATOMIC_GET	src/atomic.h	50;"	d
ATOMIC_OR	src/atomic.h	124;"	d
ATOMIC_OR	src/atomic.h	35;"	d
ATOMIC_SET	src/atomic.h	20;"	d
ATOMIC_SET	src/atomic.h	60;"	d
ATOMIC_SUB	src/atomic.h	114;"	d
ATOMIC_SUB	src/atomic.h	34;"	d
ATOMIC_SWAP	src/atomic.h	23;"	d
ATOMIC_SWAP	src/atomic.h	69;"	d
ATOMIC_USE_LOCK	src/atomic.h	47;"	d
ATOMIC_XOR	src/atomic.h	144;"	d
ATOMIC_XOR	src/atomic.h	37;"	d
CFLAGS	Makefile	/^CFLAGS=-Wall -g -pipe -march=native -Wall -Wparentheses -Winline -Wuninitialized -Wunused -Wcomment -Wformat -Wimplicit -Wsequence-point -Wfloat-equal -Wshadow -fstack-protector-all -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 --std=gnu99$/;"	m
DB_FILE_HEAD_LEN	src/mq_util.h	51;"	d
DB_FILE_HEAD_OF_COUNT_LEN	src/mq_util.h	52;"	d
DB_FILE_HEAD_OF_VERSION_LEN	src/mq_util.h	53;"	d
DB_FILE_VERSION	src/mq_util.h	54;"	d
DECLTYPE	src/uthash.h	37;"	d
DECLTYPE	src/uthash.h	40;"	d
DECLTYPE	src/uthash.h	43;"	d
DECLTYPE_ASSIGN	src/uthash.h	47;"	d
DECLTYPE_ASSIGN	src/uthash.h	53;"	d
DEF_DATA_FILE_PATH	src/mq_config.h	32;"	d
DEF_DB_FILE_MAX_SIZE	src/mq_config.h	33;"	d
DEF_MAX_QLIST_ITEMS	src/mq_config.h	27;"	d
DEF_MAX_QUEUE	src/mq_config.h	35;"	d
DEF_OUTPUT_LOG_LEVEL	src/mq_config.h	25;"	d
DEF_OUTPUT_LOG_PATH	src/mq_config.h	24;"	d
DEF_RES_STORE_SPACE	src/mq_config.h	26;"	d
DEF_SYNC_INTERVAL	src/mq_config.h	29;"	d
DEF_SYNC_TIME_INTERVAL	src/mq_config.h	30;"	d
ELMT_FROM_HH	src/uthash.h	82;"	d
FD_BLOCK	src/file.h	/^    FD_BLOCK    = 1,   \/* fd is block *\/$/;"	e	enum:fd_block
FD_INVALID	src/file.h	/^    FD_INVALID  = -1,  \/* use for avoid\/detect some errors *\/$/;"	e	enum:fd_block
FD_NONBLOCK	src/file.h	/^    FD_NONBLOCK = 2,   \/* fd is non-block *\/$/;"	e	enum:fd_block
FD_UNKNOWN	src/file.h	/^    FD_UNKNOWN  = 0,   \/* unknown block or not *\/$/;"	e	enum:fd_block
FOPEN_FLAG_CREATE	src/mq_store_file.h	/^    FOPEN_FLAG_CREATE =  0,  $/;"	e	enum:file_open_flag
FOPEN_FLAG_OPEN	src/mq_store_file.h	/^    FOPEN_FLAG_OPEN   =  1,$/;"	e	enum:file_open_flag
GCC_VERSION	src/common.h	36;"	d
GEN_DATA_FULL_PATH_BY_FNAME	src/mq_store_file.h	62;"	d
GEN_DATA_FULL_PATH_BY_QNAME_INDEX	src/mq_store_file.h	56;"	d
GEN_QUEUE_PATH_BY_QNAME	src/mq_store_file.h	38;"	d
GEN_RTAG_FULL_PATH_BY_QNAME_INDEX	src/mq_store_file.h	44;"	d
GEN_WTAG_FULL_PATH_BY_QNAME_INDEX	src/mq_store_file.h	50;"	d
HASH_ADD	src/uthash.h	149;"	d
HASH_ADD_INT	src/uthash.h	237;"	d
HASH_ADD_KEYPTR	src/uthash.h	152;"	d
HASH_ADD_PTR	src/uthash.h	241;"	d
HASH_ADD_STR	src/uthash.h	233;"	d
HASH_ADD_TO_BKT	src/uthash.h	582;"	d
HASH_BER	src/uthash.h	328;"	d
HASH_BKT_CAPACITY_THRESH	src/uthash.h	79;"	d
HASH_BLOOM_ADD	src/uthash.h	117;"	d
HASH_BLOOM_ADD	src/uthash.h	126;"	d
HASH_BLOOM_BITLEN	src/uthash.h	98;"	d
HASH_BLOOM_BITSET	src/uthash.h	114;"	d
HASH_BLOOM_BITTEST	src/uthash.h	115;"	d
HASH_BLOOM_BYTELEN	src/uthash.h	99;"	d
HASH_BLOOM_FREE	src/uthash.h	109;"	d
HASH_BLOOM_FREE	src/uthash.h	125;"	d
HASH_BLOOM_MAKE	src/uthash.h	100;"	d
HASH_BLOOM_MAKE	src/uthash.h	124;"	d
HASH_BLOOM_SIGNATURE	src/uthash.h	858;"	d
HASH_BLOOM_TEST	src/uthash.h	120;"	d
HASH_BLOOM_TEST	src/uthash.h	127;"	d
HASH_CLEAR	src/uthash.h	812;"	d
HASH_CNT	src/uthash.h	834;"	d
HASH_COUNT	src/uthash.h	833;"	d
HASH_DEL	src/uthash.h	243;"	d
HASH_DELETE	src/uthash.h	194;"	d
HASH_DEL_IN_BKT	src/uthash.h	596;"	d
HASH_EMIT_KEY	src/uthash.h	310;"	d
HASH_EMIT_KEY	src/uthash.h	317;"	d
HASH_EXPAND_BUCKETS	src/uthash.h	637;"	d
HASH_FCN	src/uthash.h	322;"	d
HASH_FCN	src/uthash.h	324;"	d
HASH_FIND	src/uthash.h	84;"	d
HASH_FIND_INT	src/uthash.h	235;"	d
HASH_FIND_IN_BKT	src/uthash.h	568;"	d
HASH_FIND_PTR	src/uthash.h	239;"	d
HASH_FIND_STR	src/uthash.h	231;"	d
HASH_FNV	src/uthash.h	350;"	d
HASH_FSCK	src/uthash.h	251;"	d
HASH_FSCK	src/uthash.h	303;"	d
HASH_INITIAL_NUM_BUCKETS	src/uthash.h	77;"	d
HASH_INITIAL_NUM_BUCKETS_LOG2	src/uthash.h	78;"	d
HASH_ITER	src/uthash.h	823;"	d
HASH_ITER	src/uthash.h	827;"	d
HASH_JEN	src/uthash.h	389;"	d
HASH_JEN_MIX	src/uthash.h	376;"	d
HASH_KEYCMP	src/uthash.h	565;"	d
HASH_MAKE_TABLE	src/uthash.h	130;"	d
HASH_MUR	src/uthash.h	527;"	d
HASH_OAT	src/uthash.h	360;"	d
HASH_OOPS	src/uthash.h	250;"	d
HASH_SAX	src/uthash.h	340;"	d
HASH_SELECT	src/uthash.h	774;"	d
HASH_SFH	src/uthash.h	441;"	d
HASH_SIGNATURE	src/uthash.h	857;"	d
HASH_SORT	src/uthash.h	689;"	d
HASH_SRT	src/uthash.h	690;"	d
HASH_TO_BKT	src/uthash.h	177;"	d
INVALID	src/common.h	/^    INVALID = 0,         \/* use for avoid\/detect some errors *\/$/;"	e	enum:OPT
IOV_MAX	src/file.c	18;"	d	file:
LIBA	Makefile	/^LIBA=-lucmq$/;"	m
LIBS	Makefile	/^LIBS=-lrt -lpthread$/;"	m
LIB_DIR	Makefile	/^LIB_DIR=.\/$/;"	m
LOG_DEBUG	src/log.h	/^    LOG_DEBUG = 10,              \/* debug *\/$/;"	e	enum:LOG_LEVEL_VALUE
LOG_ERROR	src/log.h	/^    LOG_ERROR = 10000,           \/* error *\/$/;"	e	enum:LOG_LEVEL_VALUE
LOG_FATAL	src/log.h	/^    LOG_FATAL = 65535,           \/* fatal, maybe need to reboot *\/$/;"	e	enum:LOG_LEVEL_VALUE
LOG_HAS_INIT	src/log.c	22;"	d	file:
LOG_INFO	src/log.h	/^    LOG_INFO  = 100,             \/* runtime infomation *\/$/;"	e	enum:LOG_LEVEL_VALUE
LOG_INIT_ING	src/log.c	21;"	d	file:
LOG_LEVEL_VALUE	src/log.h	/^enum LOG_LEVEL_VALUE$/;"	g
LOG_NEED_INIT	src/log.c	20;"	d	file:
LOG_TRACE	src/log.h	/^    LOG_TRACE = 0,               \/* trace run path *\/$/;"	e	enum:LOG_LEVEL_VALUE
LOG_WARN	src/log.h	/^    LOG_WARN  = 1000,            \/* some error but can fix or ignore it *\/$/;"	e	enum:LOG_LEVEL_VALUE
MAX_DATA_FILE_NAME_LEN	src/mq_util.h	58;"	d
MAX_DATA_PATH_NAME_LEN	src/mq_util.h	57;"	d
MAX_DB_FILE_SIZE	src/mq_util.h	49;"	d
MAX_DB_FILE_SIZE_LIMIT	src/mq_util.h	50;"	d
MAX_FULL_FILE_NAME_LEN	src/mq_util.h	56;"	d
MAX_QUEUE_NAME_LEN	src/mq_queue_manage.h	33;"	d
MQ_E2BIG	src/mq_errno.h	77;"	d
MQ_EACCES	src/mq_errno.h	83;"	d
MQ_EADDRINUSE	src/mq_errno.h	168;"	d
MQ_EADDRNOTAVAIL	src/mq_errno.h	169;"	d
MQ_EADV	src/mq_errno.h	138;"	d
MQ_EAFNOSUPPORT	src/mq_errno.h	167;"	d
MQ_EAGAIN	src/mq_errno.h	81;"	d
MQ_EALREADY	src/mq_errno.h	184;"	d
MQ_EBADE	src/mq_errno.h	122;"	d
MQ_EBADF	src/mq_errno.h	79;"	d
MQ_EBADFD	src/mq_errno.h	147;"	d
MQ_EBADMSG	src/mq_errno.h	144;"	d
MQ_EBADR	src/mq_errno.h	123;"	d
MQ_EBADRQC	src/mq_errno.h	126;"	d
MQ_EBADSLT	src/mq_errno.h	127;"	d
MQ_EBFONT	src/mq_errno.h	129;"	d
MQ_EBUSY	src/mq_errno.h	86;"	d
MQ_ECANCELED	src/mq_errno.h	195;"	d
MQ_ECHILD	src/mq_errno.h	80;"	d
MQ_ECHRNG	src/mq_errno.h	114;"	d
MQ_ECOMM	src/mq_errno.h	140;"	d
MQ_ECONNABORTED	src/mq_errno.h	173;"	d
MQ_ECONNREFUSED	src/mq_errno.h	181;"	d
MQ_ECONNRESET	src/mq_errno.h	174;"	d
MQ_EDEADLK	src/mq_errno.h	105;"	d
MQ_EDEADLOCK	src/mq_errno.h	128;"	d
MQ_EDESTADDRREQ	src/mq_errno.h	159;"	d
MQ_EDOM	src/mq_errno.h	103;"	d
MQ_EDOTDOT	src/mq_errno.h	143;"	d
MQ_EDQUOT	src/mq_errno.h	192;"	d
MQ_EEXIST	src/mq_errno.h	87;"	d
MQ_EFAULT	src/mq_errno.h	84;"	d
MQ_EFBIG	src/mq_errno.h	97;"	d
MQ_EHOSTDOWN	src/mq_errno.h	182;"	d
MQ_EHOSTUNREACH	src/mq_errno.h	183;"	d
MQ_EIDRM	src/mq_errno.h	113;"	d
MQ_EILSEQ	src/mq_errno.h	154;"	d
MQ_EINPROGRESS	src/mq_errno.h	185;"	d
MQ_EINTR	src/mq_errno.h	74;"	d
MQ_EINVAL	src/mq_errno.h	92;"	d
MQ_EIO	src/mq_errno.h	75;"	d
MQ_EISCONN	src/mq_errno.h	176;"	d
MQ_EISDIR	src/mq_errno.h	91;"	d
MQ_EISNAM	src/mq_errno.h	190;"	d
MQ_EKEYEXPIRED	src/mq_errno.h	197;"	d
MQ_EKEYREJECTED	src/mq_errno.h	199;"	d
MQ_EKEYREVOKED	src/mq_errno.h	198;"	d
MQ_EL2HLT	src/mq_errno.h	121;"	d
MQ_EL2NSYNC	src/mq_errno.h	115;"	d
MQ_EL3HLT	src/mq_errno.h	116;"	d
MQ_EL3RST	src/mq_errno.h	117;"	d
MQ_ELIBACC	src/mq_errno.h	149;"	d
MQ_ELIBBAD	src/mq_errno.h	150;"	d
MQ_ELIBEXEC	src/mq_errno.h	153;"	d
MQ_ELIBMAX	src/mq_errno.h	152;"	d
MQ_ELIBSCN	src/mq_errno.h	151;"	d
MQ_ELNRNG	src/mq_errno.h	118;"	d
MQ_ELOOP	src/mq_errno.h	110;"	d
MQ_EMEDIUMTYPE	src/mq_errno.h	194;"	d
MQ_EMFILE	src/mq_errno.h	94;"	d
MQ_EMLINK	src/mq_errno.h	101;"	d
MQ_EMSGSIZE	src/mq_errno.h	160;"	d
MQ_EMULTIHOP	src/mq_errno.h	142;"	d
MQ_ENAMETOOLONG	src/mq_errno.h	106;"	d
MQ_ENAVAIL	src/mq_errno.h	189;"	d
MQ_ENETDOWN	src/mq_errno.h	170;"	d
MQ_ENETRESET	src/mq_errno.h	172;"	d
MQ_ENETUNREACH	src/mq_errno.h	171;"	d
MQ_ENFILE	src/mq_errno.h	93;"	d
MQ_ENOANO	src/mq_errno.h	125;"	d
MQ_ENOBUFS	src/mq_errno.h	175;"	d
MQ_ENOCSI	src/mq_errno.h	120;"	d
MQ_ENODATA	src/mq_errno.h	131;"	d
MQ_ENODEV	src/mq_errno.h	89;"	d
MQ_ENOENT	src/mq_errno.h	72;"	d
MQ_ENOEXEC	src/mq_errno.h	78;"	d
MQ_ENOKEY	src/mq_errno.h	196;"	d
MQ_ENOLCK	src/mq_errno.h	107;"	d
MQ_ENOLINK	src/mq_errno.h	137;"	d
MQ_ENOMEDIUM	src/mq_errno.h	193;"	d
MQ_ENOMEM	src/mq_errno.h	82;"	d
MQ_ENOMSG	src/mq_errno.h	112;"	d
MQ_ENONET	src/mq_errno.h	134;"	d
MQ_ENOPKG	src/mq_errno.h	135;"	d
MQ_ENOPROTOOPT	src/mq_errno.h	162;"	d
MQ_ENOSPC	src/mq_errno.h	98;"	d
MQ_ENOSR	src/mq_errno.h	133;"	d
MQ_ENOSTR	src/mq_errno.h	130;"	d
MQ_ENOSYS	src/mq_errno.h	108;"	d
MQ_ENOTBLK	src/mq_errno.h	85;"	d
MQ_ENOTCONN	src/mq_errno.h	177;"	d
MQ_ENOTDIR	src/mq_errno.h	90;"	d
MQ_ENOTEMPTY	src/mq_errno.h	109;"	d
MQ_ENOTNAM	src/mq_errno.h	188;"	d
MQ_ENOTRECOVERABLE	src/mq_errno.h	202;"	d
MQ_ENOTSOCK	src/mq_errno.h	158;"	d
MQ_ENOTTY	src/mq_errno.h	95;"	d
MQ_ENOTUNIQ	src/mq_errno.h	146;"	d
MQ_ENXIO	src/mq_errno.h	76;"	d
MQ_EOK	src/mq_errno.h	69;"	d
MQ_EOPNOTSUPP	src/mq_errno.h	165;"	d
MQ_EOVERFLOW	src/mq_errno.h	145;"	d
MQ_EOWNERDEAD	src/mq_errno.h	201;"	d
MQ_EPERM	src/mq_errno.h	71;"	d
MQ_EPFNOSUPPORT	src/mq_errno.h	166;"	d
MQ_EPIPE	src/mq_errno.h	102;"	d
MQ_EPROTO	src/mq_errno.h	141;"	d
MQ_EPROTONOSUPPORT	src/mq_errno.h	163;"	d
MQ_EPROTOTYPE	src/mq_errno.h	161;"	d
MQ_ERANGE	src/mq_errno.h	104;"	d
MQ_EREMCHG	src/mq_errno.h	148;"	d
MQ_EREMOTE	src/mq_errno.h	136;"	d
MQ_EREMOTEIO	src/mq_errno.h	191;"	d
MQ_ERESTART	src/mq_errno.h	155;"	d
MQ_EROFS	src/mq_errno.h	100;"	d
MQ_ESHUTDOWN	src/mq_errno.h	178;"	d
MQ_ESOCKTNOSUPPORT	src/mq_errno.h	164;"	d
MQ_ESPIPE	src/mq_errno.h	99;"	d
MQ_ESRCH	src/mq_errno.h	73;"	d
MQ_ESRMNT	src/mq_errno.h	139;"	d
MQ_ESTALE	src/mq_errno.h	186;"	d
MQ_ESTRPIPE	src/mq_errno.h	156;"	d
MQ_ETIME	src/mq_errno.h	132;"	d
MQ_ETIMEDOUT	src/mq_errno.h	180;"	d
MQ_ETOOMANYREFS	src/mq_errno.h	179;"	d
MQ_ETXTBSY	src/mq_errno.h	96;"	d
MQ_EUCLEAN	src/mq_errno.h	187;"	d
MQ_EUNATCH	src/mq_errno.h	119;"	d
MQ_EUSERS	src/mq_errno.h	157;"	d
MQ_EWOULDBLOCK	src/mq_errno.h	111;"	d
MQ_EXDEV	src/mq_errno.h	88;"	d
MQ_EXFULL	src/mq_errno.h	124;"	d
MSG_CHECK_RET_CRC_ERR	src/mq_store_msg.h	/^    MSG_CHECK_RET_CRC_ERR     =  4,  $/;"	e	enum:msg_check_ret
MSG_CHECK_RET_LEN_BEY	src/mq_store_msg.h	/^    MSG_CHECK_RET_LEN_BEY     =  5,  $/;"	e	enum:msg_check_ret
MSG_CHECK_RET_MAG_NUM_ERR	src/mq_store_msg.h	/^    MSG_CHECK_RET_MAG_NUM_ERR =  2,  $/;"	e	enum:msg_check_ret
MSG_CHECK_RET_MSG_ERR	src/mq_store_msg.h	/^    MSG_CHECK_RET_MSG_ERR     =  1,  $/;"	e	enum:msg_check_ret
MSG_CHECK_RET_OK	src/mq_store_msg.h	/^    MSG_CHECK_RET_OK          =  0,  $/;"	e	enum:msg_check_ret
MSG_CHECK_RET_PARSE_ERR	src/mq_store_msg.h	/^    MSG_CHECK_RET_PARSE_ERR   =  3,  $/;"	e	enum:msg_check_ret
MSG_HEAD_LEN	src/mq_util.h	65;"	d
MSG_HEAD_OF_CRC16_LEN	src/mq_util.h	62;"	d
MSG_HEAD_OF_DELAY_LEN	src/mq_util.h	63;"	d
MSG_HEAD_OF_FIRST_MAGIC_NUM	src/mq_util.h	67;"	d
MSG_HEAD_OF_MSGLEN_LEN	src/mq_util.h	64;"	d
MSG_HEAD_OF_ONE_MAGIC_NUM_LEN	src/mq_util.h	61;"	d
MSG_HEAD_OF_SECOND_MAGIC_NUM	src/mq_util.h	68;"	d
MS_2_NS	src/util.c	24;"	d	file:
MS_2_S	src/util.c	26;"	d	file:
MUR_FMIX	src/uthash.h	518;"	d
MUR_GETBLOCK	src/uthash.h	496;"	d
MUR_GETBLOCK	src/uthash.h	512;"	d
MUR_ONE_THREE	src/uthash.h	506;"	d
MUR_ONE_THREE	src/uthash.h	510;"	d
MUR_PLUS0_ALIGNED	src/uthash.h	498;"	d
MUR_PLUS1_ALIGNED	src/uthash.h	499;"	d
MUR_PLUS2_ALIGNED	src/uthash.h	500;"	d
MUR_PLUS3_ALIGNED	src/uthash.h	501;"	d
MUR_ROTL32	src/uthash.h	517;"	d
MUR_THREE_ONE	src/uthash.h	504;"	d
MUR_THREE_ONE	src/uthash.h	508;"	d
MUR_TWO_TWO	src/uthash.h	505;"	d
MUR_TWO_TWO	src/uthash.h	509;"	d
NO_DECLTYPE	src/uthash.h	39;"	d
NS_2_MS	src/util.c	23;"	d	file:
NS_2_S	src/util.c	21;"	d	file:
OBJ	Makefile	/^OBJ = $(addprefix $(OBJ_DIR)\/, \\$/;"	m
OBJ_DIR	Makefile	/^OBJ_DIR=.\/obj$/;"	m
OFF	src/common.h	/^    OFF     = 2,         \/* turn off some options *\/$/;"	e	enum:OPT
ON	src/common.h	/^    ON      = 1,         \/* turn on some options *\/$/;"	e	enum:OPT
OPT	src/common.h	/^enum OPT$/;"	g
PRINT_FUNC	src/internal.h	27;"	d
PRINT_MACRO	src/internal.h	29;"	d
QUEUE_FULL	src/mq_queue_manage.h	/^    QUEUE_FULL        =  1,$/;"	e	enum:queue_put_ret
QUEUE_GET_END	src/mq_queue_manage.h	/^    QUEUE_GET_END     =  1,$/;"	e	enum:queue_get_ret
QUEUE_GET_ERROR	src/mq_queue_manage.h	/^    QUEUE_GET_ERROR   =  2,$/;"	e	enum:queue_get_ret
QUEUE_GET_OK	src/mq_queue_manage.h	/^    QUEUE_GET_OK      =  0,$/;"	e	enum:queue_get_ret
QUEUE_MAX_SIZE_LEN	src/mq_store_wtag.h	33;"	d
QUEUE_PUT_ERROR	src/mq_queue_manage.h	/^    QUEUE_PUT_ERROR   =  3,$/;"	e	enum:queue_put_ret
QUEUE_PUT_OK	src/mq_queue_manage.h	/^    QUEUE_PUT_OK      =  0,$/;"	e	enum:queue_put_ret
QUEUE_WLOCK	src/mq_queue_manage.h	/^    QUEUE_WLOCK       =  2,$/;"	e	enum:queue_put_ret
RCOUNT_LEN	src/mq_store_rtag.h	31;"	d
READ_OPT_TIMEOUT	src/mq_store_rtag.h	26;"	d
READ_OPT_TIMEOUT	src/mq_store_wtag.h	26;"	d
REDIR_ERR	src/util.h	/^    REDIR_ERR = 4,         \/* redir stderr to \/dev\/null *\/$/;"	e	enum:STD_REDIR
REDIR_IN	src/util.h	/^    REDIR_IN  = 1,         \/* redir stdin to \/dev\/null  *\/$/;"	e	enum:STD_REDIR
REDIR_OUT	src/util.h	/^    REDIR_OUT = 2,         \/* redir stdout to \/dev\/null *\/$/;"	e	enum:STD_REDIR
RPOS_LEN	src/mq_store_rtag.h	32;"	d
RTAG_FILE_HEAD_LEN	src/mq_store_rtag.h	33;"	d
RTAG_ITEM_LEN	src/mq_store_rtag.h	30;"	d
SRC	Makefile	/^SRC=.\/src$/;"	m
STD_REDIR	src/util.h	/^enum STD_REDIR$/;"	g
STR_TO_LL	src/mq_store_rtag.c	22;"	d	file:
STR_TO_LL	src/mq_store_wtag.c	22;"	d	file:
S_2_MS	src/util.c	25;"	d	file:
S_2_NS	src/util.c	22;"	d	file:
TARGET	Makefile	/^TARGET=libucmq.a$/;"	m
TEST	Makefile	/^TEST=test_ucmq$/;"	m
TEST_OBJ	Makefile	/^TEST_OBJ = $(addprefix $(OBJ_DIR)\/, main.o)$/;"	m
UNUSED	src/internal.h	24;"	d
UTHASH_H	src/uthash.h	25;"	d
UTHASH_VERSION	src/uthash.h	67;"	d
UT_hash_bucket	src/uthash.h	/^typedef struct UT_hash_bucket {$/;"	s
UT_hash_bucket	src/uthash.h	/^} UT_hash_bucket;$/;"	t	typeref:struct:UT_hash_bucket
UT_hash_bucket::count	src/uthash.h	/^   unsigned count;$/;"	m	struct:UT_hash_bucket	access:public
UT_hash_bucket::expand_mult	src/uthash.h	/^   unsigned expand_mult;$/;"	m	struct:UT_hash_bucket	access:public
UT_hash_bucket::hh_head	src/uthash.h	/^   struct UT_hash_handle *hh_head;$/;"	m	struct:UT_hash_bucket	typeref:struct:UT_hash_bucket::UT_hash_handle	access:public
UT_hash_handle	src/uthash.h	/^typedef struct UT_hash_handle {$/;"	s
UT_hash_handle	src/uthash.h	/^} UT_hash_handle;$/;"	t	typeref:struct:UT_hash_handle
UT_hash_handle::hashv	src/uthash.h	/^   unsigned hashv;                   \/* result of hash-fcn(key)        *\/$/;"	m	struct:UT_hash_handle	access:public
UT_hash_handle::hh_next	src/uthash.h	/^   struct UT_hash_handle *hh_next;   \/* next hh in bucket order        *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle	access:public
UT_hash_handle::hh_prev	src/uthash.h	/^   struct UT_hash_handle *hh_prev;   \/* previous hh in bucket order    *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle	access:public
UT_hash_handle::key	src/uthash.h	/^   void *key;                        \/* ptr to enclosing struct's key  *\/$/;"	m	struct:UT_hash_handle	access:public
UT_hash_handle::keylen	src/uthash.h	/^   unsigned keylen;                  \/* enclosing struct's key len     *\/$/;"	m	struct:UT_hash_handle	access:public
UT_hash_handle::next	src/uthash.h	/^   void *next;                       \/* next element in app order      *\/$/;"	m	struct:UT_hash_handle	access:public
UT_hash_handle::prev	src/uthash.h	/^   void *prev;                       \/* prev element in app order      *\/$/;"	m	struct:UT_hash_handle	access:public
UT_hash_handle::tbl	src/uthash.h	/^   struct UT_hash_table *tbl;$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_table	access:public
UT_hash_table	src/uthash.h	/^typedef struct UT_hash_table {$/;"	s
UT_hash_table	src/uthash.h	/^} UT_hash_table;$/;"	t	typeref:struct:UT_hash_table
UT_hash_table::bloom_bv	src/uthash.h	/^   uint8_t *bloom_bv;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::bloom_nbits	src/uthash.h	/^   char bloom_nbits;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::bloom_sig	src/uthash.h	/^   uint32_t bloom_sig; \/* used only to test bloom exists in external analysis *\/$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::buckets	src/uthash.h	/^   UT_hash_bucket *buckets;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::hho	src/uthash.h	/^   ptrdiff_t hho; \/* hash handle offset (byte pos of hash handle in element *\/$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::ideal_chain_maxlen	src/uthash.h	/^   unsigned ideal_chain_maxlen;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::ineff_expands	src/uthash.h	/^   unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::log2_num_buckets	src/uthash.h	/^   unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::noexpand	src/uthash.h	/^   unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::nonideal_items	src/uthash.h	/^   unsigned nonideal_items;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::num_buckets	src/uthash.h	/^   unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::num_items	src/uthash.h	/^   unsigned num_items;$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::signature	src/uthash.h	/^   uint32_t signature; \/* used only to find hash tables in external analysis *\/$/;"	m	struct:UT_hash_table	access:public
UT_hash_table::tail	src/uthash.h	/^   struct UT_hash_handle *tail; \/* tail hh in app order, for fast append    *\/$/;"	m	struct:UT_hash_table	typeref:struct:UT_hash_table::UT_hash_handle	access:public
WCOUNT_LEN	src/mq_store_wtag.h	31;"	d
WP	src/uthash.h	502;"	d
WPOS_LEN	src/mq_store_wtag.h	32;"	d
WRITE_OPT_TIMEOUT	src/mq_store_rtag.h	27;"	d
WRITE_OPT_TIMEOUT	src/mq_store_wtag.h	27;"	d
WTAG_FILE_HEAD_LEN	src/mq_store_wtag.h	34;"	d
WTAG_ITEM_LEN	src/mq_store_wtag.h	30;"	d
_FILE_OFFSET_BITS	src/file.c	2;"	d	file:
_LARGEFILE64_SOURCE	src/file.c	6;"	d	file:
__ATOMIC_H__	src/atomic.h	2;"	d
__COMMON_H__	src/common.h	16;"	d
__CRC16_H__	src/crc16.h	2;"	d
__FILE_H__	src/file.h	2;"	d
__INTERNAL_H__	src/internal.h	2;"	d
__LOG_H__	src/log.h	2;"	d
__MQ_CONFIG_H__	src/mq_config.h	16;"	d
__MQ_ERRNO_H__	src/mq_errno.h	16;"	d
__MQ_QUEUE_MANAGE_H__	src/mq_queue_manage.h	16;"	d
__MQ_STORE_FILE_H__	src/mq_store_file.h	16;"	d
__MQ_STORE_MANAGE_H__	src/mq_store_manage.h	16;"	d
__MQ_STORE_MSG_H__	src/mq_store_msg.h	16;"	d
__MQ_STORE_RTAG_H__	src/mq_store_rtag.h	16;"	d
__MQ_STORE_wtag_H__	src/mq_store_wtag.h	16;"	d
__MQ_UTIL_H__	src/mq_util.h	16;"	d
__UTIL_H__	src/util.h	2;"	d
_queue	src/main.c	/^typedef struct _queue$/;"	s	file:
_queue::is_quit	src/main.c	/^    bool is_quit;$/;"	m	struct:_queue	file:	access:public
_queue::qname	src/main.c	/^    char qname[16];$/;"	m	struct:_queue	file:	access:public
_queue::recv	src/main.c	/^    char recv[64];$/;"	m	struct:_queue	file:	access:public
_queue::send	src/main.c	/^    char send[64];$/;"	m	struct:_queue	file:	access:public
app_info	src/mq_api.c	/^typedef struct app_info$/;"	s	file:
app_info::count	src/mq_api.c	/^    uint64_t     count;$/;"	m	struct:app_info	file:	access:public
app_info::get	src/mq_api.c	/^    uint32_t     get;$/;"	m	struct:app_info	file:	access:public
app_info::max_time	src/mq_api.c	/^    uint32_t     max_time;$/;"	m	struct:app_info	file:	access:public
app_info::mutex	src/mq_api.c	/^    pthread_mutex_t mutex;$/;"	m	struct:app_info	file:	access:public
app_info::put	src/mq_api.c	/^    uint32_t     put;$/;"	m	struct:app_info	file:	access:public
app_info::put_size	src/mq_api.c	/^    uint64_t     put_size;$/;"	m	struct:app_info	file:	access:public
app_info::times	src/mq_api.c	/^    uint32_t     times;$/;"	m	struct:app_info	file:	access:public
app_info::total_time	src/mq_api.c	/^    uint32_t     total_time;$/;"	m	struct:app_info	file:	access:public
app_info_t	src/mq_api.c	/^} app_info_t;$/;"	t	typeref:struct:app_info	file:
block_read_n	src/file.c	/^static inline int32_t block_read_n(int fd, void* buf, int32_t size, int32_t timeout)$/;"	f	file:	signature:(int fd, void* buf, int32_t size, int32_t timeout)
block_read_n	src/file.c	/^static inline int32_t block_read_n(int fd, void* buf, int32_t size, int32_t timeout);$/;"	p	file:	signature:(int fd, void* buf, int32_t size, int32_t timeout)
block_write_n	src/file.c	/^static inline int32_t block_write_n(int fd, const void* buf, int32_t size, int32_t timeout)$/;"	f	file:	signature:(int fd, const void* buf, int32_t size, int32_t timeout)
block_write_n	src/file.c	/^static inline int32_t block_write_n(int fd, const void* buf, int32_t size, int32_t timeout);$/;"	p	file:	signature:(int fd, const void* buf, int32_t size, int32_t timeout)
bloom_bv	src/uthash.h	/^   uint8_t *bloom_bv;$/;"	m	struct:UT_hash_table	access:public
bloom_nbits	src/uthash.h	/^   char bloom_nbits;$/;"	m	struct:UT_hash_table	access:public
bloom_sig	src/uthash.h	/^   uint32_t bloom_sig; \/* used only to test bloom exists in external analysis *\/$/;"	m	struct:UT_hash_table	access:public
buckets	src/uthash.h	/^   UT_hash_bucket *buckets;$/;"	m	struct:UT_hash_table	access:public
check_rtag_item	src/mq_store_rtag.c	/^static bool check_rtag_item(mq_queue_t *mq_queue)$/;"	f	file:	signature:(mq_queue_t *mq_queue)
check_rtag_item	src/mq_store_rtag.c	/^static bool check_rtag_item(mq_queue_t *mq_queue);$/;"	p	file:	signature:(mq_queue_t *mq_queue)
check_wtag_item	src/mq_store_wtag.c	/^static bool check_wtag_item(mq_queue_t *mq_queue)$/;"	f	file:	signature:(mq_queue_t *mq_queue)
check_wtag_item	src/mq_store_wtag.c	/^static bool check_wtag_item(mq_queue_t *mq_queue);$/;"	p	file:	signature:(mq_queue_t *mq_queue)
count	src/mq_api.c	/^    uint64_t     count;$/;"	m	struct:app_info	file:	access:public
count	src/uthash.h	/^   unsigned count;$/;"	m	struct:UT_hash_bucket	access:public
crc16	src/mq_util.h	/^    uint16_t       crc16;          \/* message body crc16 *\/$/;"	m	struct:msg_item	access:public
crc16_append	src/crc16.c	/^bool crc16_append(uint16_t* crc16, const void* data, int32_t len)$/;"	f	signature:(uint16_t* crc16, const void* data, int32_t len)
crc16_append	src/crc16.h	/^extern bool crc16_append(uint16_t* crc16, const void* data, int32_t len);$/;"	p	signature:(uint16_t* crc16, const void* data, int32_t len)
crc16tab	src/crc16.c	/^static const uint16_t crc16tab[]={$/;"	v	file:
cur_index	src/mq_util.h	/^    uint64_t       cur_index;$/;"	m	struct:mq_db_map	access:public
cur_rdb	src/mq_util.h	/^    mq_db_map_t    cur_rdb;        \/* current read db *\/$/;"	m	struct:mq_queue	access:public
cur_wdb	src/mq_util.h	/^    mq_db_map_t    cur_wdb;        \/* current write db *\/$/;"	m	struct:mq_queue	access:public
data_file_path	src/mq_config.h	/^    char         data_file_path[128];    \/* data_path *\/$/;"	m	struct:ucmq_conf	access:public
day	src/log.c	/^        uint16_t    day;$/;"	m	struct:time_info::__anon1	file:	access:public
db_file_max_size	src/mq_config.h	/^    int          db_file_max_size;       \/* db file size *\/$/;"	m	struct:ucmq_conf	access:public
def_max_queue	src/mq_config.h	/^    uint32_t     def_max_queue;          \/* queue_size *\/$/;"	m	struct:ucmq_conf	access:public
delay	src/mq_util.h	/^    uint32_t       delay;          \/* message delay *\/$/;"	m	struct:msg_item	access:public
delete_file	src/mq_util.c	/^void delete_file(const char *path)$/;"	f	signature:(const char *path)
delete_file	src/mq_util.h	/^void delete_file(const char *path);$/;"	p	signature:(const char *path)
do_getpid	src/util.h	174;"	d
do_gettid	src/util.c	/^int do_gettid(void)$/;"	f	signature:(void)
do_gettid	src/util.h	/^extern int do_gettid(void);$/;"	p	signature:(void)
do_mkdir	src/util.c	/^int do_mkdir(const char* dir, mode_t mode)$/;"	f	signature:(const char* dir, mode_t mode)
do_mkdir	src/util.h	/^extern int do_mkdir(const char* dir, mode_t mode);$/;"	p	signature:(const char* dir, mode_t mode)
do_sleep	src/util.c	/^int do_sleep(int32_t timeout)$/;"	f	signature:(int32_t timeout)
do_sleep	src/util.h	/^extern int do_sleep(int32_t timeout);$/;"	p	signature:(int32_t timeout)
expand_mult	src/uthash.h	/^   unsigned expand_mult;$/;"	m	struct:UT_hash_bucket	access:public
extend_file_size	src/mq_util.c	/^bool extend_file_size(const int fd, off_t length)$/;"	f	signature:(const int fd, off_t length)
extend_file_size	src/mq_util.h	/^bool extend_file_size(const int fd, off_t length);$/;"	p	signature:(const int fd, off_t length)
fd	src/mq_util.h	/^    int            fd;$/;"	m	struct:mq_db_map	access:public
fd_block	src/file.h	/^typedef enum fd_block$/;"	g
fd_block_e	src/file.h	/^} fd_block_e;$/;"	t	typeref:enum:fd_block
file_open_flag	src/mq_store_file.h	/^typedef enum file_open_flag $/;"	g
file_open_flag_e	src/mq_store_file.h	/^}file_open_flag_e;$/;"	t	typeref:enum:file_open_flag
find_handle_file	src/mq_store_file.c	/^bool find_handle_file(queue_file_t *queue_file, char *qname)$/;"	f	signature:(queue_file_t *queue_file, char *qname)
find_handle_file	src/mq_store_file.h	/^bool find_handle_file(queue_file_t *queue_file, char *qname);$/;"	p	signature:(queue_file_t *queue_file, char *qname)
flag	src/mq_util.h	/^    int            flag;          \/* is mmap flag *\/$/;"	m	struct:mq_db_map	access:public
g_config	src/log.c	/^static log_config_t g_config;$/;"	v	file:
g_has_fork	src/log.c	/^static volatile int     g_has_fork = 0;$/;"	v	file:
g_has_init	src/log.c	/^static volatile int     g_has_init = 0;$/;"	v	file:
g_index	src/main.c	/^int g_index = 0;$/;"	v
g_info	src/mq_api.c	/^app_info_t g_info;$/;"	v
g_last_info	src/mq_api.c	/^app_info_t g_last_info;$/;"	v
g_mq_conf	src/mq_config.c	/^ucmq_conf_t g_mq_conf =$/;"	v
g_mq_qlist	src/mq_queue_manage.c	/^mq_queue_list_t* g_mq_qlist;$/;"	v
g_pid	src/log.c	/^static volatile pid_t   g_pid      = 0;$/;"	v	file:
get	src/mq_api.c	/^    uint32_t     get;$/;"	m	struct:app_info	file:	access:public
get16bits	src/uthash.h	431;"	d
get16bits	src/uthash.h	434;"	d
get16bits	src/uthash.h	438;"	d
get_a_msg	src/main.c	/^void *get_a_msg(void *args)$/;"	f	signature:(void *args)
get_abs_time	src/util.c	/^struct timespec get_abs_time(int32_t time_affter)$/;"	f	signature:(int32_t time_affter)
get_abs_time	src/util.h	/^extern struct timespec get_abs_time(int32_t time_affter);$/;"	p	signature:(int32_t time_affter)
get_cur_timestamp	src/mq_util.c	/^int get_cur_timestamp() $/;"	f
get_cur_timestamp	src/mq_util.h	/^int  get_cur_timestamp(void);$/;"	p	signature:(void)
get_file_path	src/mq_util.c	/^void get_file_path(const char *path, const char *file_name,  char *file_path)$/;"	f	signature:(const char *path, const char *file_name, char *file_path)
get_file_size	src/mq_util.c	/^int get_file_size(const char *path)$/;"	f	signature:(const char *path)
get_file_size	src/mq_util.h	/^int  get_file_size(const char* path);$/;"	p	signature:(const char* path)
get_id_by_fname	src/mq_store_file.c	/^static uint64_t get_id_by_fname(const char *qname);$/;"	p	file:	signature:(const char *qname)
get_id_by_fname	src/mq_store_file.c	/^static uint64_t get_id_by_fname(const char* qname)$/;"	f	file:	signature:(const char* qname)
get_msg	src/main.c	/^void *get_msg(void *args)$/;"	f	signature:(void *args)
get_next_read_file	src/mq_store_file.c	/^bool get_next_read_file(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
get_next_read_file	src/mq_store_file.h	/^bool get_next_read_file(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
get_next_write_file	src/mq_store_file.c	/^bool get_next_write_file(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
get_next_write_file	src/mq_store_file.h	/^bool get_next_write_file(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
get_num	src/mq_util.h	/^    uint64_t       get_num;        \/* get msg number *\/$/;"	m	struct:mq_queue	access:public
get_page_size	src/mq_util.c	/^int get_page_size()$/;"	f
get_page_size	src/mq_util.h	/^int  get_page_size(void);$/;"	p	signature:(void)
get_rand	src/util.h	/^extern int32_t get_rand(void);$/;"	p	signature:(void)
get_rel_time	src/util.c	/^int32_t get_rel_time(const struct timespec* abs_time)$/;"	f	signature:(const struct timespec* abs_time)
get_rel_time	src/util.h	/^extern int32_t get_rel_time(const struct timespec* abs_time);$/;"	p	signature:(const struct timespec* abs_time)
get_self_path	src/util.c	/^const char* get_self_path(void)$/;"	f	signature:(void)
get_self_path	src/util.h	/^extern const char* get_self_path(void);$/;"	p	signature:(void)
get_storage_free	src/mq_util.c	/^int get_storage_free(const char* path)$/;"	f	signature:(const char* path)
get_storage_free	src/mq_util.h	/^int  get_storage_free(const char* path);$/;"	p	signature:(const char* path)
get_time	src/log.c	/^static time_info get_time(void)$/;"	f	file:	signature:(void)
get_time	src/log.c	/^static time_info get_time(void);$/;"	p	file:	signature:(void)
get_time_diff_nsec	src/util.c	/^int64_t get_time_diff_nsec(const struct timespec* start, const struct timespec* end)$/;"	f	signature:(const struct timespec* start, const struct timespec* end)
get_time_diff_nsec	src/util.h	/^extern int64_t get_time_diff_nsec(const struct timespec* start,$/;"	p	signature:(const struct timespec* start, const struct timespec* end)
get_time_diff_sec	src/util.c	/^double get_time_diff_sec(const struct timespec* start, const struct timespec* end)$/;"	f	signature:(const struct timespec* start, const struct timespec* end)
get_time_diff_sec	src/util.h	/^extern double get_time_diff_sec(const struct timespec* start,$/;"	p	signature:(const struct timespec* start, const struct timespec* end)
get_time_tick	src/util.c	/^struct timespec get_time_tick(void)$/;"	f	signature:(void)
get_time_tick	src/util.h	/^extern struct timespec get_time_tick(void);$/;"	p	signature:(void)
hash_add_queue_kv	src/mq_queue_manage.c	/^mq_queue_t* hash_add_queue_kv(const char* qname, mq_queue_t* queue)$/;"	f	signature:(const char* qname, mq_queue_t* queue)
hash_clear_queue	src/mq_queue_manage.c	/^bool hash_clear_queue()$/;"	f
hash_del_queue	src/mq_queue_manage.c	/^void hash_del_queue(const char* qname)$/;"	f	signature:(const char* qname)
hash_find_queue_by_key	src/mq_queue_manage.c	/^mq_queue_t* hash_find_queue_by_key(const char* qname)$/;"	f	signature:(const char* qname)
hash_get_queue_num	src/mq_queue_manage.c	/^int hash_get_queue_num()$/;"	f
hash_print_table	src/mq_queue_manage.c	/^void hash_print_table()$/;"	f
hashv	src/uthash.h	/^   unsigned hashv;                   \/* result of hash-fcn(key)        *\/$/;"	m	struct:UT_hash_handle	access:public
hh	src/mq_util.h	/^    UT_hash_handle hh;             \/* makes this structure hashable *\/$/;"	m	struct:mq_queue_list	access:public
hh_head	src/uthash.h	/^   struct UT_hash_handle *hh_head;$/;"	m	struct:UT_hash_bucket	typeref:struct:UT_hash_bucket::UT_hash_handle	access:public
hh_next	src/uthash.h	/^   struct UT_hash_handle *hh_next;   \/* next hh in bucket order        *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle	access:public
hh_prev	src/uthash.h	/^   struct UT_hash_handle *hh_prev;   \/* previous hh in bucket order    *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle	access:public
hho	src/uthash.h	/^   ptrdiff_t hho; \/* hash handle offset (byte pos of hash handle in element *\/$/;"	m	struct:UT_hash_table	access:public
hour	src/log.c	/^        uint8_t     hour;$/;"	m	struct:time_info::__anon1	file:	access:public
ideal_chain_maxlen	src/uthash.h	/^   unsigned ideal_chain_maxlen;$/;"	m	struct:UT_hash_table	access:public
ineff_expands	src/uthash.h	/^   unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table	access:public
init_queue	src/mq_queue_manage.c	/^static bool init_queue(mq_queue_t *mq_queue)$/;"	f	file:	signature:(mq_queue_t *mq_queue)
init_queue	src/mq_queue_manage.c	/^static bool init_queue(mq_queue_t *mq_queue);$/;"	p	file:	signature:(mq_queue_t *mq_queue)
is_dir	src/mq_util.c	/^bool is_dir(const char *path)$/;"	f	signature:(const char *path)
is_dir	src/mq_util.h	/^bool is_dir(const char *path);$/;"	p	signature:(const char *path)
is_file	src/mq_util.c	/^bool is_file(const char *path)$/;"	f	signature:(const char *path)
is_file	src/mq_util.h	/^bool is_file(const char *path);$/;"	p	signature:(const char *path)
is_nonblock	src/file.c	/^static inline int is_nonblock(int fd, fd_block_e block_type)$/;"	f	file:	signature:(int fd, fd_block_e block_type)
is_nonblock	src/file.c	/^static inline int is_nonblock(int fd, fd_block_e block_type);$/;"	p	file:	signature:(int fd, fd_block_e block_type)
is_num_str	src/mq_util.c	/^int is_num_str(const char *s)$/;"	f	signature:(const char *s)
is_num_str	src/mq_util.h	/^int  is_num_str(const char *s);$/;"	p	signature:(const char *s)
is_quit	src/main.c	/^    bool is_quit;$/;"	m	struct:_queue	file:	access:public
is_special_dir	src/mq_util.c	/^bool is_special_dir(const char *path)$/;"	f	signature:(const char *path)
is_special_dir	src/mq_util.h	/^bool is_special_dir(const char *path);$/;"	p	signature:(const char *path)
key	src/uthash.h	/^   void *key;                        \/* ptr to enclosing struct's key  *\/$/;"	m	struct:UT_hash_handle	access:public
keylen	src/uthash.h	/^   unsigned keylen;                  \/* enclosing struct's key len     *\/$/;"	m	struct:UT_hash_handle	access:public
len	src/mq_util.h	/^    uint32_t       len;            \/* message body len *\/$/;"	m	struct:msg_item	access:public
log2_num_buckets	src/uthash.h	/^   unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table	access:public
log_config	src/log.h	/^typedef struct log_config$/;"	s
log_config::log_file	src/log.h	/^    char        log_file[NAME_MAX]; \/* log file prefix *\/$/;"	m	struct:log_config	access:public
log_config::log_level	src/log.h	/^    uint16_t    log_level;          \/* output log level *\/$/;"	m	struct:log_config	access:public
log_config::log_path	src/log.h	/^    char        log_path[PATH_MAX]; \/* log dir *\/$/;"	m	struct:log_config	access:public
log_config::time_zone	src/log.h	/^    uint32_t    time_zone;          \/* local time zone (GMT+8 should be 8) *\/$/;"	m	struct:log_config	access:public
log_config_t	src/log.h	/^}log_config_t;$/;"	t	typeref:struct:log_config
log_debug	src/log.h	17;"	d
log_error	src/log.h	20;"	d
log_fatal	src/log.h	21;"	d
log_file	src/log.h	/^    char        log_file[NAME_MAX]; \/* log file prefix *\/$/;"	m	struct:log_config	access:public
log_info	src/log.h	18;"	d
log_init	src/log.c	/^int log_init(const log_config_t* config)$/;"	f	signature:(const log_config_t* config)
log_init	src/log.h	/^extern int log_init(const log_config_t* config);$/;"	p	signature:(const log_config_t* config)
log_init_config	src/log.c	/^void log_init_config(log_config_t* config)$/;"	f	signature:(log_config_t* config)
log_init_config	src/log.h	/^extern void log_init_config(log_config_t* config);$/;"	p	signature:(log_config_t* config)
log_level	src/log.h	/^    uint16_t    log_level;          \/* output log level *\/$/;"	m	struct:log_config	access:public
log_path	src/log.h	/^    char        log_path[PATH_MAX]; \/* log dir *\/$/;"	m	struct:log_config	access:public
log_trace	src/log.h	16;"	d
log_warn	src/log.h	19;"	d
log_write	src/log.c	/^void log_write(const char* module, $/;"	f	signature:(const char* module, const char* file, int line, uint16_t level, const char* format, ...)
log_write	src/log.h	/^extern void log_write(const char* module, $/;"	p	signature:(const char* module, const char* file, int line, uint16_t level, const char* format, ...)
log_write_impl	src/log.c	/^static void log_write_impl(const char* module, $/;"	f	file:	signature:(const char* module, const char* file, int line, uint16_t level, const char* level_str, const char* format, va_list ap)
log_write_impl	src/log.c	/^static void log_write_impl(const char* module, $/;"	p	file:	signature:(const char* module, const char* file, int line, uint16_t level, const char* level_str, const char* format, va_list ap)
log_writev	src/log.c	/^void log_writev(const char* module, $/;"	f	signature:(const char* module, const char* file, int line, uint16_t level, const char* format, va_list ap)
log_writev	src/log.h	/^extern void log_writev(const char* module, $/;"	p	signature:(const char* module, const char* file, int line, uint16_t level, const char* format, va_list ap)
magic_num1	src/mq_util.h	/^    char           magic_num1;     \/* magic number *\/$/;"	m	struct:msg_item	access:public
magic_num2	src/mq_util.h	/^    char           magic_num2;     \/* magic number *\/$/;"	m	struct:msg_item	access:public
main	src/main.c	/^int main()$/;"	f
map_mem	src/mq_util.h	/^    char           *map_mem;$/;"	m	struct:mq_db_map	access:public
max	src/mq_util.c	/^inline int max(int a, int b) {return (a < b) ? b : a;}$/;"	f	signature:(int a, int b)
max	src/mq_util.h	/^int max(int a, int b);$/;"	p	signature:(int a, int b)
max_qlist_itmes	src/mq_config.h	/^    int          max_qlist_itmes;        \/* queue list items limit *\/$/;"	m	struct:ucmq_conf	access:public
max_time	src/mq_api.c	/^    uint32_t     max_time;$/;"	m	struct:app_info	file:	access:public
maxque	src/mq_util.h	/^    uint32_t       maxque;         \/* mas queue items *\/$/;"	m	struct:mq_queue	access:public
min	src/log.c	/^        uint8_t     min;$/;"	m	struct:time_info::__anon1	file:	access:public
min	src/mq_util.c	/^inline int min(int a, int b) {return (a >= b) ? b : a;}$/;"	f	signature:(int a, int b)
min	src/mq_util.h	/^int min(int a, int b); $/;"	p	signature:(int a, int b)
mq_db_map	src/mq_util.h	/^typedef struct mq_db_map$/;"	s
mq_db_map::cur_index	src/mq_util.h	/^    uint64_t       cur_index;$/;"	m	struct:mq_db_map	access:public
mq_db_map::fd	src/mq_util.h	/^    int            fd;$/;"	m	struct:mq_db_map	access:public
mq_db_map::flag	src/mq_util.h	/^    int            flag;          \/* is mmap flag *\/$/;"	m	struct:mq_db_map	access:public
mq_db_map::map_mem	src/mq_util.h	/^    char           *map_mem;$/;"	m	struct:mq_db_map	access:public
mq_db_map::opt_count	src/mq_util.h	/^    uint32_t       opt_count;$/;"	m	struct:mq_db_map	access:public
mq_db_map::pos	src/mq_util.h	/^    uint32_t       pos;$/;"	m	struct:mq_db_map	access:public
mq_db_map::stat	src/mq_util.h	/^    int            stat;$/;"	m	struct:mq_db_map	access:public
mq_db_map_t	src/mq_util.h	/^}mq_db_map_t;$/;"	t	typeref:struct:mq_db_map
mq_errno	src/mq_errno.c	/^int32_t mq_errno(void)$/;"	f	signature:(void)
mq_errno	src/mq_errno.h	/^extern int32_t mq_errno(void);$/;"	p	signature:(void)
mq_last_error	src/mq_errno.c	/^const char* mq_last_error(void)$/;"	f	signature:(void)
mq_last_error	src/mq_errno.h	/^extern const char* mq_last_error(void);$/;"	p	signature:(void)
mq_qm_add_queue	src/mq_queue_manage.c	/^mq_queue_t* mq_qm_add_queue(const char *qname)$/;"	f	signature:(const char *qname)
mq_qm_add_queue	src/mq_queue_manage.h	/^mq_queue_t* mq_qm_add_queue(const char* qname);$/;"	p	signature:(const char* qname)
mq_qm_close_store	src/mq_queue_manage.c	/^bool mq_qm_close_store(void)$/;"	f	signature:(void)
mq_qm_close_store	src/mq_queue_manage.h	/^bool     mq_qm_close_store(void);$/;"	p	signature:(void)
mq_qm_db_sync	src/mq_queue_manage.c	/^static bool mq_qm_db_sync(mq_queue_t *mq_queue)$/;"	f	file:	signature:(mq_queue_t *mq_queue)
mq_qm_db_sync	src/mq_queue_manage.c	/^static bool mq_qm_db_sync(mq_queue_t *mq_queue);$/;"	p	file:	signature:(mq_queue_t *mq_queue)
mq_qm_del_queue	src/mq_queue_manage.c	/^bool mq_qm_del_queue(const char *qname)$/;"	f	signature:(const char *qname)
mq_qm_del_queue	src/mq_queue_manage.h	/^bool mq_qm_del_queue(const char* qname);$/;"	p	signature:(const char* qname)
mq_qm_find_queue	src/mq_queue_manage.c	/^mq_queue_t* mq_qm_find_queue(const char *qname)$/;"	f	signature:(const char *qname)
mq_qm_find_queue	src/mq_queue_manage.h	/^mq_queue_t* mq_qm_find_queue(const char *qname);$/;"	p	signature:(const char *qname)
mq_qm_get_store_count	src/mq_queue_manage.c	/^uint64_t mq_qm_get_store_count(void)$/;"	f	signature:(void)
mq_qm_get_store_count	src/mq_queue_manage.h	/^uint64_t mq_qm_get_store_count(void);$/;"	p	signature:(void)
mq_qm_open_store	src/mq_queue_manage.c	/^bool mq_qm_open_store(void)$/;"	f	signature:(void)
mq_qm_open_store	src/mq_queue_manage.h	/^bool     mq_qm_open_store(void);$/;"	p	signature:(void)
mq_qm_pop_item	src/mq_queue_manage.c	/^int mq_qm_pop_item(mq_queue_t *mq_queue, msg_item_t *msg_item)$/;"	f	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_qm_pop_item	src/mq_queue_manage.h	/^int  mq_qm_pop_item(mq_queue_t *mq_queue, msg_item_t *msg_item);$/;"	p	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_qm_push_item	src/mq_queue_manage.c	/^int mq_qm_push_item(mq_queue_t *mq_queue, msg_item_t *msg_item)$/;"	f	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_qm_push_item	src/mq_queue_manage.h	/^int  mq_qm_push_item(mq_queue_t *mq_queue, msg_item_t *msg_item);$/;"	p	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_qm_set_maxqueue	src/mq_queue_manage.c	/^bool mq_qm_set_maxqueue(mq_queue_t *mq_queue, uint32_t dest_max_queue_size)$/;"	f	signature:(mq_queue_t *mq_queue, uint32_t dest_max_queue_size)
mq_qm_set_maxqueue	src/mq_queue_manage.h	/^bool mq_qm_set_maxqueue(mq_queue_t *mq_queue, uint32_t max_queue);$/;"	p	signature:(mq_queue_t *mq_queue, uint32_t max_queue)
mq_qm_set_synctime	src/mq_queue_manage.c	/^bool mq_qm_set_synctime(int sync_interval)$/;"	f	signature:(int sync_interval)
mq_qm_set_synctime	src/mq_queue_manage.h	/^bool mq_qm_set_synctime(int sync_interval);$/;"	p	signature:(int sync_interval)
mq_qm_sync_store	src/mq_queue_manage.c	/^void mq_qm_sync_store(void)$/;"	f	signature:(void)
mq_qm_sync_store	src/mq_queue_manage.h	/^void     mq_qm_sync_store(void);$/;"	p	signature:(void)
mq_queue	src/mq_util.h	/^    mq_queue_t mq_queue;           \/* node of hash table *\/$/;"	m	struct:mq_queue_list	access:public
mq_queue	src/mq_util.h	/^typedef struct mq_queue$/;"	s
mq_queue::cur_rdb	src/mq_util.h	/^    mq_db_map_t    cur_rdb;        \/* current read db *\/$/;"	m	struct:mq_queue	access:public
mq_queue::cur_wdb	src/mq_util.h	/^    mq_db_map_t    cur_wdb;        \/* current write db *\/$/;"	m	struct:mq_queue	access:public
mq_queue::get_num	src/mq_util.h	/^    uint64_t       get_num;        \/* get msg number *\/$/;"	m	struct:mq_queue	access:public
mq_queue::maxque	src/mq_util.h	/^    uint32_t       maxque;         \/* mas queue items *\/$/;"	m	struct:mq_queue	access:public
mq_queue::mutex	src/mq_util.h	/^    pthread_mutex_t mutex;$/;"	m	struct:mq_queue	access:public
mq_queue::put_num	src/mq_util.h	/^    uint64_t       put_num;        \/* put msg number *\/$/;"	m	struct:mq_queue	access:public
mq_queue::qname	src/mq_util.h	/^    char           qname[32 + 1];  \/* queue name *\/$/;"	m	struct:mq_queue	access:public
mq_queue::rtag_fd	src/mq_util.h	/^    int            rtag_fd;        \/* rtag file fd *\/$/;"	m	struct:mq_queue	access:public
mq_queue::sync_intv	src/mq_util.h	/^    int            sync_intv;      \/* sync inteval *\/$/;"	m	struct:mq_queue	access:public
mq_queue::wtag_fd	src/mq_util.h	/^    int            wtag_fd;        \/* rtag file fd *\/$/;"	m	struct:mq_queue	access:public
mq_queue_list	src/mq_util.h	/^typedef struct mq_queue_list$/;"	s
mq_queue_list::hh	src/mq_util.h	/^    UT_hash_handle hh;             \/* makes this structure hashable *\/$/;"	m	struct:mq_queue_list	access:public
mq_queue_list::mq_queue	src/mq_util.h	/^    mq_queue_t mq_queue;           \/* node of hash table *\/$/;"	m	struct:mq_queue_list	access:public
mq_queue_list::qname	src/mq_util.h	/^    char qname[32 + 1];            \/* key *\/$/;"	m	struct:mq_queue_list	access:public
mq_queue_list_t	src/mq_util.h	/^}mq_queue_list_t;$/;"	t	typeref:struct:mq_queue_list
mq_queue_t	src/mq_util.h	/^}mq_queue_t;$/;"	t	typeref:struct:mq_queue
mq_sm_close_db	src/mq_store_manage.c	/^bool mq_sm_close_db(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_close_db	src/mq_store_manage.h	/^bool mq_sm_close_db(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_close_db_file	src/mq_store_manage.c	/^static bool mq_sm_close_db_file(void* map_mem, int fd)$/;"	f	file:	signature:(void* map_mem, int fd)
mq_sm_close_db_file	src/mq_store_manage.c	/^static bool mq_sm_close_db_file(void* map_mem, int fd);$/;"	p	file:	signature:(void* map_mem, int fd)
mq_sm_creat_db	src/mq_store_manage.c	/^bool mq_sm_creat_db(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_creat_db	src/mq_store_manage.h	/^bool mq_sm_creat_db(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_db_build_msg_crc16	src/mq_store_msg.c	/^bool mq_sm_db_build_msg_crc16(uint16_t* crc, const char* data, int len)$/;"	f	signature:(uint16_t* crc, const char* data, int len)
mq_sm_db_build_msg_crc16	src/mq_store_msg.h	/^bool mq_sm_db_build_msg_crc16(uint16_t* crc, const char* data, int len);$/;"	p	signature:(uint16_t* crc, const char* data, int len)
mq_sm_db_cal_msg_count	src/mq_store_msg.c	/^uint32_t mq_sm_db_cal_msg_count(int fd, uint32_t end_pos)$/;"	f	signature:(int fd, uint32_t end_pos)
mq_sm_db_cal_msg_count	src/mq_store_msg.h	/^uint32_t mq_sm_db_cal_msg_count(int fd, uint32_t end_pos);$/;"	p	signature:(int fd, uint32_t end_pos)
mq_sm_db_parse_msg	src/mq_store_msg.c	/^int mq_sm_db_parse_msg(const char* msg, uint32_t cur_pos, msg_item_t* msg_item)$/;"	f	signature:(const char* msg, uint32_t cur_pos, msg_item_t* msg_item)
mq_sm_db_parse_msg	src/mq_store_msg.h	/^int  mq_sm_db_parse_msg(const char* msg, uint32_t cur_pos, msg_item_t* msg_item);$/;"	p	signature:(const char* msg, uint32_t cur_pos, msg_item_t* msg_item)
mq_sm_db_parse_msg_head	src/mq_store_msg.c	/^bool mq_sm_db_parse_msg_head(msg_item_t *item, const char *msg_head)$/;"	f	signature:(msg_item_t *item, const char *msg_head)
mq_sm_db_parse_msg_head	src/mq_store_msg.h	/^bool mq_sm_db_parse_msg_head(msg_item_t *item, const char *msg_head);$/;"	p	signature:(msg_item_t *item, const char *msg_head)
mq_sm_db_write_file_head	src/mq_store_msg.c	/^bool mq_sm_db_write_file_head(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_db_write_file_head	src/mq_store_msg.h	/^bool mq_sm_db_write_file_head(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_db_write_msg	src/mq_store_msg.c	/^bool mq_sm_db_write_msg(mq_queue_t *mq_queue, msg_item_t *msg_item)$/;"	f	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_sm_db_write_msg	src/mq_store_msg.h	/^bool mq_sm_db_write_msg(mq_queue_t *mq_queue, msg_item_t *msg_item);$/;"	p	signature:(mq_queue_t *mq_queue, msg_item_t *msg_item)
mq_sm_get_data	src/mq_store_manage.c	/^bool mq_sm_get_data(msg_item_t* msg_item, mq_queue_t* mq_queue)$/;"	f	signature:(msg_item_t* msg_item, mq_queue_t* mq_queue)
mq_sm_get_data	src/mq_store_manage.h	/^bool mq_sm_get_data(msg_item_t *msg_item, mq_queue_t *mq_queue);$/;"	p	signature:(msg_item_t *msg_item, mq_queue_t *mq_queue)
mq_sm_get_msg_count	src/mq_store_manage.c	/^uint64_t mq_sm_get_msg_count(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_get_msg_count	src/mq_store_manage.h	/^uint64_t mq_sm_get_msg_count(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_open_db	src/mq_store_manage.c	/^bool mq_sm_open_db(mq_queue_t *mq_queue, queue_file_t *queue_file)$/;"	f	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_open_db	src/mq_store_manage.h	/^bool mq_sm_open_db(mq_queue_t *mq_queue, queue_file_t *queue_file);$/;"	p	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_open_db_file	src/mq_store_file.c	/^char* mq_sm_open_db_file(int* fd, const char* db_fname, int open_flag)$/;"	f	signature:(int* fd, const char* db_fname, int open_flag)
mq_sm_open_db_file	src/mq_store_file.h	/^char* mq_sm_open_db_file(int* fd, const char* db_fname, int open_flag);$/;"	p	signature:(int* fd, const char* db_fname, int open_flag)
mq_sm_put_data	src/mq_store_manage.c	/^bool mq_sm_put_data(msg_item_t *msg_item, mq_queue_t *mq_queue)$/;"	f	signature:(msg_item_t *msg_item, mq_queue_t *mq_queue)
mq_sm_put_data	src/mq_store_manage.h	/^bool mq_sm_put_data(msg_item_t *msg_item, mq_queue_t *mq_queue);$/;"	p	signature:(msg_item_t *msg_item, mq_queue_t *mq_queue)
mq_sm_remove_db	src/mq_store_manage.c	/^bool mq_sm_remove_db(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_remove_db	src/mq_store_manage.h	/^bool mq_sm_remove_db(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_close_file	src/mq_store_rtag.c	/^bool mq_sm_rtag_close_file(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_close_file	src/mq_store_rtag.h	/^bool mq_sm_rtag_close_file(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_open_file	src/mq_store_rtag.c	/^bool mq_sm_rtag_open_file(mq_queue_t *mq_queue, queue_file_t *queue_file)$/;"	f	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_rtag_open_file	src/mq_store_rtag.h	/^bool mq_sm_rtag_open_file(mq_queue_t *mq_queue, queue_file_t *queue_file);$/;"	p	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_rtag_open_next_file	src/mq_store_rtag.c	/^int mq_sm_rtag_open_next_file(const char* file_name)$/;"	f	signature:(const char* file_name)
mq_sm_rtag_open_next_file	src/mq_store_rtag.h	/^int  mq_sm_rtag_open_next_file(const char* file_name);$/;"	p	signature:(const char* file_name)
mq_sm_rtag_read_item	src/mq_store_rtag.c	/^bool mq_sm_rtag_read_item(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_read_item	src/mq_store_rtag.h	/^bool mq_sm_rtag_read_item(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_write_item	src/mq_store_rtag.c	/^bool mq_sm_rtag_write_item(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_rtag_write_item	src/mq_store_rtag.h	/^bool mq_sm_rtag_write_item(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_close_file	src/mq_store_wtag.c	/^bool mq_sm_wtag_close_file(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_close_file	src/mq_store_wtag.h	/^bool mq_sm_wtag_close_file(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_open_file	src/mq_store_wtag.c	/^bool mq_sm_wtag_open_file(mq_queue_t *mq_queue, queue_file_t *queue_file)$/;"	f	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_wtag_open_file	src/mq_store_wtag.h	/^bool mq_sm_wtag_open_file(mq_queue_t *mq_queue, queue_file_t *queue_file);$/;"	p	signature:(mq_queue_t *mq_queue, queue_file_t *queue_file)
mq_sm_wtag_open_next_file	src/mq_store_wtag.c	/^int mq_sm_wtag_open_next_file(const char* file_name)$/;"	f	signature:(const char* file_name)
mq_sm_wtag_open_next_file	src/mq_store_wtag.h	/^int  mq_sm_wtag_open_next_file(const char* file_name);$/;"	p	signature:(const char* file_name)
mq_sm_wtag_read_item	src/mq_store_wtag.c	/^bool mq_sm_wtag_read_item(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_read_item	src/mq_store_wtag.h	/^bool mq_sm_wtag_read_item(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_write_item	src/mq_store_wtag.c	/^bool mq_sm_wtag_write_item(mq_queue_t *mq_queue)$/;"	f	signature:(mq_queue_t *mq_queue)
mq_sm_wtag_write_item	src/mq_store_wtag.h	/^bool mq_sm_wtag_write_item(mq_queue_t *mq_queue);$/;"	p	signature:(mq_queue_t *mq_queue)
mq_store_close	src/mq_api.c	/^void mq_store_close(void)$/;"	f	signature:(void)
mq_store_close	src/mq_api.h	/^void mq_store_close(void);$/;"	p	signature:(void)
mq_store_get	src/mq_api.c	/^bool mq_store_get(const char *qname, char *msg, int msg_len)$/;"	f	signature:(const char *qname, char *msg, int msg_len)
mq_store_get	src/mq_api.h	/^bool mq_store_get(const char *qname, char *msg, int msg_len);$/;"	p	signature:(const char *qname, char *msg, int msg_len)
mq_store_init	src/mq_api.c	/^bool mq_store_init(const char *log_path, const char *data_path)$/;"	f	signature:(const char *log_path, const char *data_path)
mq_store_init	src/mq_api.h	/^bool mq_store_init(const char *log_path, const char *data_path);$/;"	p	signature:(const char *log_path, const char *data_path)
mq_store_put	src/mq_api.c	/^bool mq_store_put(const char *qname, const char *msg, int msg_len)$/;"	f	signature:(const char *qname, const char *msg, int msg_len)
mq_store_put	src/mq_api.h	/^bool mq_store_put(const char *qname, const char *msg, int msg_len);$/;"	p	signature:(const char *qname, const char *msg, int msg_len)
mq_strerror	src/mq_errno.c	/^const char* mq_strerror(int32_t error_number)$/;"	f	signature:(int32_t error_number)
mq_strerror	src/mq_errno.h	/^extern const char* mq_strerror(int32_t error_number);$/;"	p	signature:(int32_t error_number)
msec	src/log.c	/^        uint16_t    msec;$/;"	m	struct:time_info::__anon1	file:	access:public
msg	src/mq_util.h	/^    char           *msg;           \/* message message boby *\/$/;"	m	struct:msg_item	access:public
msg_check_ret	src/mq_store_msg.h	/^typedef enum msg_check_ret$/;"	g
msg_check_ret_e	src/mq_store_msg.h	/^}msg_check_ret_e;$/;"	t	typeref:enum:msg_check_ret
msg_item	src/mq_util.h	/^typedef struct msg_item$/;"	s
msg_item::crc16	src/mq_util.h	/^    uint16_t       crc16;          \/* message body crc16 *\/$/;"	m	struct:msg_item	access:public
msg_item::delay	src/mq_util.h	/^    uint32_t       delay;          \/* message delay *\/$/;"	m	struct:msg_item	access:public
msg_item::len	src/mq_util.h	/^    uint32_t       len;            \/* message body len *\/$/;"	m	struct:msg_item	access:public
msg_item::magic_num1	src/mq_util.h	/^    char           magic_num1;     \/* magic number *\/$/;"	m	struct:msg_item	access:public
msg_item::magic_num2	src/mq_util.h	/^    char           magic_num2;     \/* magic number *\/$/;"	m	struct:msg_item	access:public
msg_item::msg	src/mq_util.h	/^    char           *msg;           \/* message message boby *\/$/;"	m	struct:msg_item	access:public
msg_item_t	src/mq_util.h	/^}msg_item_t;$/;"	t	typeref:struct:msg_item
mutex	src/mq_api.c	/^    pthread_mutex_t mutex;$/;"	m	struct:app_info	file:	access:public
mutex	src/mq_util.h	/^    pthread_mutex_t mutex;$/;"	m	struct:mq_queue	access:public
next	src/uthash.h	/^   void *next;                       \/* next element in app order      *\/$/;"	m	struct:UT_hash_handle	access:public
noexpand	src/uthash.h	/^   unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table	access:public
nonblock_read_n	src/file.c	/^static inline int32_t nonblock_read_n(int fd, void* buf, int32_t size, int32_t timeout)$/;"	f	file:	signature:(int fd, void* buf, int32_t size, int32_t timeout)
nonblock_read_n	src/file.c	/^static inline int32_t nonblock_read_n(int fd, void* buf, int32_t size, int32_t timeout);$/;"	p	file:	signature:(int fd, void* buf, int32_t size, int32_t timeout)
nonblock_write_n	src/file.c	/^static inline int32_t nonblock_write_n(int fd, const void* buf, int32_t size, int32_t timeout)$/;"	f	file:	signature:(int fd, const void* buf, int32_t size, int32_t timeout)
nonblock_write_n	src/file.c	/^static inline int32_t nonblock_write_n(int fd, const void* buf, int32_t size, int32_t timeout);$/;"	p	file:	signature:(int fd, const void* buf, int32_t size, int32_t timeout)
nonideal_items	src/uthash.h	/^   unsigned nonideal_items;$/;"	m	struct:UT_hash_table	access:public
num_buckets	src/uthash.h	/^   unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table	access:public
num_items	src/uthash.h	/^   unsigned num_items;$/;"	m	struct:UT_hash_table	access:public
open_log	src/log.c	/^static inline int open_log(volatile int* fd);$/;"	p	file:	signature:(volatile int* fd)
open_log	src/log.c	/^static int open_log(volatile int* fd)$/;"	f	file:	signature:(volatile int* fd)
opt_count	src/mq_util.h	/^    uint32_t       opt_count;$/;"	m	struct:mq_db_map	access:public
output_log_level	src/mq_config.h	/^    char         output_log_level[16];   \/* log_level *\/$/;"	m	struct:ucmq_conf	access:public
output_log_path	src/mq_config.h	/^    char         output_log_path[128];   \/* log_path *\/$/;"	m	struct:ucmq_conf	access:public
parse_rtag_item	src/mq_store_rtag.c	/^static bool parse_rtag_item(mq_queue_t *mq_queue, char *rtag_str)$/;"	f	file:	signature:(mq_queue_t *mq_queue, char *rtag_str)
parse_rtag_item	src/mq_store_rtag.c	/^static bool parse_rtag_item(mq_queue_t *mq_queue, char *rtag_str);$/;"	p	file:	signature:(mq_queue_t *mq_queue, char *rtag_str)
parse_wtag_item	src/mq_store_wtag.c	/^static bool parse_wtag_item(mq_queue_t *mq_queue, char *wtag_str)$/;"	f	file:	signature:(mq_queue_t *mq_queue, char *wtag_str)
parse_wtag_item	src/mq_store_wtag.c	/^static bool parse_wtag_item(mq_queue_t *mq_queue, char *wtag_str);$/;"	p	file:	signature:(mq_queue_t *mq_queue, char *wtag_str)
pos	src/mq_util.h	/^    uint32_t       pos;$/;"	m	struct:mq_db_map	access:public
prev	src/uthash.h	/^   void *prev;                       \/* prev element in app order      *\/$/;"	m	struct:UT_hash_handle	access:public
put	src/mq_api.c	/^    uint32_t     put;$/;"	m	struct:app_info	file:	access:public
put_a_msg	src/main.c	/^void *put_a_msg(void *args)$/;"	f	signature:(void *args)
put_msg	src/main.c	/^void *put_msg(void *args)$/;"	f	signature:(void *args)
put_num	src/mq_util.h	/^    uint64_t       put_num;        \/* put msg number *\/$/;"	m	struct:mq_queue	access:public
put_size	src/mq_api.c	/^    uint64_t     put_size;$/;"	m	struct:app_info	file:	access:public
qname	src/main.c	/^    char qname[16];$/;"	m	struct:_queue	file:	access:public
qname	src/mq_util.h	/^    char           qname[32 + 1];  \/* queue name *\/$/;"	m	struct:mq_queue	access:public
qname	src/mq_util.h	/^    char qname[32 + 1];            \/* key *\/$/;"	m	struct:mq_queue_list	access:public
qname_check	src/mq_api.c	/^static int qname_check(const char* qname)$/;"	f	file:	signature:(const char* qname)
queue_file	src/mq_util.h	/^typedef struct queue_file$/;"	s
queue_file::read_fid	src/mq_util.h	/^    uint64_t       read_fid;             \/* cur read file index *\/$/;"	m	struct:queue_file	access:public
queue_file::read_fname	src/mq_util.h	/^    char           read_fname[64 + 1];   \/* read file name *\/$/;"	m	struct:queue_file	access:public
queue_file::rtag_fid	src/mq_util.h	/^    uint64_t       rtag_fid;             \/* cur rtag file index *\/$/;"	m	struct:queue_file	access:public
queue_file::rtag_fname	src/mq_util.h	/^    char           rtag_fname[64 + 1];   \/* rtag file name *\/$/;"	m	struct:queue_file	access:public
queue_file::write_fid	src/mq_util.h	/^    uint64_t       write_fid;            \/* cur write file index *\/$/;"	m	struct:queue_file	access:public
queue_file::write_fname	src/mq_util.h	/^    char           write_fname[64 + 1];  \/* write file name *\/$/;"	m	struct:queue_file	access:public
queue_file::wtag_fid	src/mq_util.h	/^    uint64_t       wtag_fid;             \/* cur rtag file index *\/$/;"	m	struct:queue_file	access:public
queue_file::wtag_fname	src/mq_util.h	/^    char           wtag_fname[64 + 1];   \/* rtag file name *\/$/;"	m	struct:queue_file	access:public
queue_file_t	src/mq_util.h	/^}queue_file_t;$/;"	t	typeref:struct:queue_file
queue_get_ret	src/mq_queue_manage.h	/^typedef enum queue_get_ret$/;"	g
queue_get_ret_e	src/mq_queue_manage.h	/^}queue_get_ret_e;$/;"	t	typeref:enum:queue_get_ret
queue_put_ret	src/mq_queue_manage.h	/^typedef enum queue_put_ret$/;"	g
queue_put_ret_e	src/mq_queue_manage.h	/^}queue_put_ret_e;$/;"	t	typeref:enum:queue_put_ret
queue_t	src/main.c	/^} queue_t;$/;"	t	typeref:struct:_queue	file:
read_fid	src/mq_util.h	/^    uint64_t       read_fid;             \/* cur read file index *\/$/;"	m	struct:queue_file	access:public
read_file	src/mq_util.c	/^int read_file(char* buffer, int size, const char* path)$/;"	f	signature:(char* buffer, int size, const char* path)
read_file	src/mq_util.h	/^int  read_file(char* buffer, int size, const char* path);$/;"	p	signature:(char* buffer, int size, const char* path)
read_fname	src/mq_util.h	/^    char           read_fname[64 + 1];   \/* read file name *\/$/;"	m	struct:queue_file	access:public
read_n	src/file.c	/^int32_t read_n(int fd, fd_block_e block_type, void* buf, int32_t size, int32_t timeout)$/;"	f	signature:(int fd, fd_block_e block_type, void* buf, int32_t size, int32_t timeout)
read_n	src/file.h	/^extern int32_t read_n(int fd,                    $/;"	p	signature:(int fd, fd_block_e block_type, void* buf, int32_t size, int32_t timeout)
recv	src/main.c	/^    char recv[64];$/;"	m	struct:_queue	file:	access:public
res_store_space	src/mq_config.h	/^    uint64_t     res_store_space;$/;"	m	struct:ucmq_conf	access:public
rtag_fd	src/mq_util.h	/^    int            rtag_fd;        \/* rtag file fd *\/$/;"	m	struct:mq_queue	access:public
rtag_fid	src/mq_util.h	/^    uint64_t       rtag_fid;             \/* cur rtag file index *\/$/;"	m	struct:queue_file	access:public
rtag_fname	src/mq_util.h	/^    char           rtag_fname[64 + 1];   \/* rtag file name *\/$/;"	m	struct:queue_file	access:public
sec	src/log.c	/^        uint8_t     sec;$/;"	m	struct:time_info::__anon1	file:	access:public
send	src/main.c	/^    char send[64];$/;"	m	struct:_queue	file:	access:public
set_errno	src/internal.h	/^extern int32_t set_errno(int32_t error_number);$/;"	p	signature:(int32_t error_number)
set_errno	src/mq_errno.c	/^int32_t set_errno(int32_t error_number)$/;"	f	signature:(int32_t error_number)
set_rand	src/util.c	/^int32_t set_rand(void)$/;"	f	signature:(void)
set_sig_mask	src/util.c	/^int set_sig_mask(enum OPT opt, int count, ...)$/;"	f	signature:(enum OPT opt, int count, ...)
set_sig_mask	src/util.h	/^extern int set_sig_mask(enum OPT opt, int count, ...);$/;"	p	signature:(enum OPT opt, int count, ...)
signature	src/uthash.h	/^   uint32_t signature; \/* used only to find hash tables in external analysis *\/$/;"	m	struct:UT_hash_table	access:public
stat	src/mq_util.h	/^    int            stat;$/;"	m	struct:mq_db_map	access:public
str_to_ll	src/mq_util.c	/^long long int str_to_ll(const char* str)$/;"	f	signature:(const char* str)
str_to_ll	src/mq_util.h	/^long long int str_to_ll(const char* str);$/;"	p	signature:(const char* str)
str_to_num	src/mq_store_rtag.c	/^static bool str_to_num(uint64_t* num, const char* str, int len)$/;"	f	file:	signature:(uint64_t* num, const char* str, int len)
str_to_num	src/mq_store_rtag.c	/^static bool str_to_num(uint64_t* num, const char* str, int len);$/;"	p	file:	signature:(uint64_t* num, const char* str, int len)
str_to_num	src/mq_store_wtag.c	/^static bool str_to_num(uint64_t* num, const char* str, int len)$/;"	f	file:	signature:(uint64_t* num, const char* str, int len)
str_to_num	src/mq_store_wtag.c	/^static bool str_to_num(uint64_t* num, const char* str, int len);$/;"	p	file:	signature:(uint64_t* num, const char* str, int len)
sync_interval	src/mq_config.h	/^    int          sync_interval;$/;"	m	struct:ucmq_conf	access:public
sync_intv	src/mq_util.h	/^    int            sync_intv;      \/* sync inteval *\/$/;"	m	struct:mq_queue	access:public
sync_time_interval	src/mq_config.h	/^    int          sync_time_interval;$/;"	m	struct:ucmq_conf	access:public
tail	src/uthash.h	/^   struct UT_hash_handle *tail; \/* tail hh in app order, for fast append    *\/$/;"	m	struct:UT_hash_table	typeref:struct:UT_hash_table::UT_hash_handle	access:public
tbl	src/uthash.h	/^   struct UT_hash_table *tbl;$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_table	access:public
time_info	src/log.c	/^typedef union time_info$/;"	u	file:
time_info	src/log.c	/^}time_info;$/;"	t	typeref:union:time_info	file:
time_info::__anon1::day	src/log.c	/^        uint16_t    day;$/;"	m	struct:time_info::__anon1	file:	access:public
time_info::__anon1::hour	src/log.c	/^        uint8_t     hour;$/;"	m	struct:time_info::__anon1	file:	access:public
time_info::__anon1::min	src/log.c	/^        uint8_t     min;$/;"	m	struct:time_info::__anon1	file:	access:public
time_info::__anon1::msec	src/log.c	/^        uint16_t    msec;$/;"	m	struct:time_info::__anon1	file:	access:public
time_info::__anon1::sec	src/log.c	/^        uint8_t     sec;$/;"	m	struct:time_info::__anon1	file:	access:public
time_info::value	src/log.c	/^    uint64_t        value;$/;"	m	union:time_info	file:	access:public
time_zone	src/log.h	/^    uint32_t    time_zone;          \/* local time zone (GMT+8 should be 8) *\/$/;"	m	struct:log_config	access:public
times	src/mq_api.c	/^    uint32_t     times;$/;"	m	struct:app_info	file:	access:public
total_time	src/mq_api.c	/^    uint32_t     total_time;$/;"	m	struct:app_info	file:	access:public
touch_data_path	src/mq_store_file.c	/^bool touch_data_path(const char* path)$/;"	f	signature:(const char* path)
touch_data_path	src/mq_store_file.h	/^bool touch_data_path(const char* path);$/;"	p	signature:(const char* path)
ucmq_conf	src/mq_config.h	/^typedef struct ucmq_conf$/;"	s
ucmq_conf::data_file_path	src/mq_config.h	/^    char         data_file_path[128];    \/* data_path *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::db_file_max_size	src/mq_config.h	/^    int          db_file_max_size;       \/* db file size *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::def_max_queue	src/mq_config.h	/^    uint32_t     def_max_queue;          \/* queue_size *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::max_qlist_itmes	src/mq_config.h	/^    int          max_qlist_itmes;        \/* queue list items limit *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::output_log_level	src/mq_config.h	/^    char         output_log_level[16];   \/* log_level *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::output_log_path	src/mq_config.h	/^    char         output_log_path[128];   \/* log_path *\/$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::res_store_space	src/mq_config.h	/^    uint64_t     res_store_space;$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::sync_interval	src/mq_config.h	/^    int          sync_interval;$/;"	m	struct:ucmq_conf	access:public
ucmq_conf::sync_time_interval	src/mq_config.h	/^    int          sync_time_interval;$/;"	m	struct:ucmq_conf	access:public
ucmq_conf_t	src/mq_config.h	/^}ucmq_conf_t;$/;"	t	typeref:struct:ucmq_conf
uint32_t	src/uthash.h	/^typedef unsigned int uint32_t;$/;"	t
uint8_t	src/uthash.h	/^typedef unsigned char uint8_t;$/;"	t
uthash_expand_fyi	src/uthash.h	74;"	d
uthash_fatal	src/uthash.h	69;"	d
uthash_free	src/uthash.h	71;"	d
uthash_malloc	src/uthash.h	70;"	d
uthash_noexpand_fyi	src/uthash.h	73;"	d
value	src/log.c	/^    uint64_t        value;$/;"	m	union:time_info	file:	access:public
wait_fd	src/file.c	/^int wait_fd(int fd, short events, int32_t timeout)$/;"	f	signature:(int fd, short events, int32_t timeout)
wait_fd	src/file.h	/^extern int wait_fd(int fd, short events, int32_t timeout);$/;"	p	signature:(int fd, short events, int32_t timeout)
write_2_file	src/log.c	/^static inline void write_2_file(int fd, const char* buf, int size);$/;"	p	file:	signature:(int fd, const char* buf, int size)
write_2_file	src/log.c	/^static void write_2_file(int fd, const char* buf, int size)$/;"	f	file:	signature:(int fd, const char* buf, int size)
write_fid	src/mq_util.h	/^    uint64_t       write_fid;            \/* cur write file index *\/$/;"	m	struct:queue_file	access:public
write_fname	src/mq_util.h	/^    char           write_fname[64 + 1];  \/* write file name *\/$/;"	m	struct:queue_file	access:public
write_n	src/file.c	/^int32_t write_n(int fd, fd_block_e block_type, const void* buf, int32_t size, int32_t timeout)$/;"	f	signature:(int fd, fd_block_e block_type, const void* buf, int32_t size, int32_t timeout)
write_n	src/file.h	/^extern int32_t write_n(int fd,                   $/;"	p	signature:(int fd, fd_block_e block_type, const void* buf, int32_t size, int32_t timeout)
wtag_fd	src/mq_util.h	/^    int            wtag_fd;        \/* rtag file fd *\/$/;"	m	struct:mq_queue	access:public
wtag_fid	src/mq_util.h	/^    uint64_t       wtag_fid;             \/* cur rtag file index *\/$/;"	m	struct:queue_file	access:public
wtag_fname	src/mq_util.h	/^    char           wtag_fname[64 + 1];   \/* rtag file name *\/$/;"	m	struct:queue_file	access:public
